<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-01-06 Mon 09:34 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>WatchWhatIDo</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Hidemaro Fujinami">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="http://taopeng.me/org-notes-style/css/notes.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<header>
<h1 class="title">WatchWhatIDo</h1>
</header>

<div id="outline-container-org3efa0a1" class="outline-2">
<h2 id="org3efa0a1"><span class="section-number-2">1</span> &ldquo;watch what i do&rdquo;</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org26bad24" class="outline-3">
<h3 id="org26bad24"><span class="section-number-3">1.1</span> key sentences</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-org7cc91bb" class="outline-4">
<h4 id="org7cc91bb"><span class="section-number-4">1.1.1</span> foreword by Alan Kay</h4>
<div class="outline-text-4" id="text-1-1-1">
</div>
<ol class="org-ol">
<li><a id="org633c664"></a>We have macro capture systems of every kind, and scripting languages. But we don&rsquo;t have &ldquo;end-user programming&rdquo;. Nor do we have &ldquo;programming by example&rdquo;.<br>
<div class="outline-text-5" id="text-1-1-1-1">
</div>
</li>
</ol>
</div>
<div id="outline-container-orgb221af4" class="outline-4">
<h4 id="orgb221af4"><span class="section-number-4">1.1.2</span> introduction: Bringing programming to End Users</h4>
<div class="outline-text-4" id="text-1-1-2">
</div>
<ol class="org-ol">
<li><a id="org9f6a208"></a>the motivation behind Programming by Demonstration is simple and compelling<br>
<ol class="org-ol">
<li><a id="org7425c9c"></a>instead of creating a program to perform a task, user should be able to nstruct the computer &ldquo;watch what i do&rdquo;<br></li>
</ol>
</li>
<li><a id="org6f9ca93"></a>Why Would Users Want to Program?<br>
<ol class="org-ol">
<li><a id="orgb7fb1c7"></a>in the 1960s computer users wer either programmers themselves, or they had programmers who wrote programs specifically for them<br></li>
<li><a id="org1e60e9e"></a>with the advent of personal computing, people use a generic application developed by a distant, unknown and unreachable programmer to handle tasks similar to theirs<br></li>
<li><a id="org50c8b31"></a>Contemporary computer users are &ldquo;end users&rdquo;<br>
<ol class="org-ol">
<li><a id="org351dcb5"></a>they are at the end of the process of computer programming, far removed from the programmer<br></li>
</ol>
</li>
<li><a id="org4ddcd23"></a>As a result, end users must map their activities into the capabilities of the generic applications<br></li>
</ol>
</li>
<li><a id="org12ea514"></a>End User Programming<br>
<ol class="org-ol">
<li><a id="org2bff190"></a>ironic situation<br>
<ol class="org-ol">
<li><a id="org5c42698"></a>it is a truism that computers are good at performing repetitive activities. so why is it that we are the ones performing all of the repetition instead of computer?<br></li>
</ol>
</li>
<li><a id="orgf0a50a5"></a>current approaches to end user programming can be lumped into four categories<br>
<ol class="org-ol">
<li><a id="org69fd845"></a>Preference<br>
<ol class="org-ol">
<li><a id="orgf8ed079"></a>to accommodate the varying needs of several different types of users<br></li>
<li><a id="orge83ae6c"></a>but there are never be a complicated option, or finding options from hundreds of entries must be untenable<br></li>
</ol>
</li>
<li><a id="org7ddcc23"></a>scripting languages<br>
<ol class="org-ol">
<li><a id="orgb0756f4"></a>a small, simple programming language<br></li>
<li><a id="orgdff5409"></a>but the difficulties of programming remain<br></li>
</ol>
</li>
<li><a id="orgbc629fc"></a>macro recorders<br>
<ol class="org-ol">
<li><a id="orgad5a9cb"></a>provide a way to record their actions<br></li>
<li><a id="org96b85c0"></a>the main failing of mactro recorders is that they are to literal<br></li>
</ol>
</li>
<li><a id="org9c78638"></a>programming by demonstration<br>
<ol class="org-ol">
<li><a id="org810cd82"></a>an elaboration of the idea behind macro recorders<br></li>
<li><a id="org18e9be5"></a>the user instructs the system to &ldquo;Watch What I Do&rdquo;, but with programmin gby demonstration, the system creates generalized programs from the recorded actions.<br></li>
<li><a id="orgda8dc2e"></a>the greatest advantage of programming by Demonstration over conventional programming is that it is &ldquo;Programming in the User Interface&rdquo;.<br></li>
<li><a id="org779855b"></a>conventional programming requires the programmer to map from the visual representation of objects being moved about the screen into a completely different textural representation of those actions. By Programming in the User Interface users can refer to an action by simply performing the action, something they already know how to do. they are programming in the same environment in which they perform the actions.<br></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><a id="org373c6e8"></a>What Do Users Want to program?<br>
<ol class="org-ol">
<li><a id="org4f80c84"></a>the simplest types of activities involve making little chages in an aplication so that it more closely fits one&rsquo;s personal needs<br></li>
<li><a id="org41d87ae"></a>the largest potential use for programming by demonstration is for automating repetitive activities<br></li>
<li><a id="org5b27c1d"></a>the third potential use for programming by demonstration is for building mini-applications<br></li>
</ol>
</li>
<li><a id="org2bea80e"></a>what makes PBD difficult?<br>
<ol class="org-ol">
<li><a id="org35befff"></a>there is more to a program than meets the recording<br></li>
<li><a id="org149d0a7"></a>users are quietly and imperceptible making dicisions. they are searching by eye. they are reading and understanding natural language. they are interpreting the interface inn terms of their goals<br></li>
</ol>
</li>
<li><a id="org96865d8"></a>Inferring intent<br>
<ol class="org-ol">
<li><a id="orgb6f0c1d"></a>the main challenge confronting Programming By demonstration is how to infer the uesr&rsquo;s intent<br></li>
<li><a id="org1a6b3ae"></a>given the paucity of information in recording of user actions, how can a PBD system ge the additional information it needs to make the correct generalizzations<br></li>
<li><a id="org6334971"></a>in addition to inferring data descriptions, the other main type of inference that PBD systems must make is about flow of control, since repetitive activities often include special cases that must be handled differently. this poses two complications<br>
<ol class="org-ol">
<li><a id="orge30e4aa"></a>first, a single recording can only show one of the multiple paths of action, so branching flow of control will necessarily require the user to redo the activity a number of times<br></li>
<li><a id="orga490635"></a>second, the process that users go through in deciding which branch to perform is almost always a hidden mental process, and it is difficult to aquire information about how that decisio is made<br></li>
</ol>
</li>
</ol>
</li>
</ol>
</div>
<div id="outline-container-org6dad1a1" class="outline-4">
<h4 id="org6dad1a1"><span class="section-number-4">1.1.3</span> Pygmalion:An Executable Electronic Blackboard</h4>
<div class="outline-text-4" id="text-1-1-3">
</div>
<ol class="org-ol">
<li><a id="org7f314f7"></a>Introduced two new concepts: programming by demonstration and icons<br></li>
<li><a id="org8c93b6c"></a>Human-Computer Communication<br>
<ol class="org-ol">
<li><a id="org6a1b444"></a>compile-run-debug-edit periods is obviously a poor way to communicate because<br>
<ol class="org-ol">
<li><a id="orgd4613ca"></a>too abstract<br></li>
<li><a id="orgbe42a5b"></a>non-interactive<br></li>
<li><a id="orga87502e"></a>fregean<br>
<ol class="org-ol">
<li><a id="orgb326d0a"></a>Analogical - Apple Macintosh &ldquo;desktop&rdquo; user interface: they are a metaphor for the physical office<br></li>
<li><a id="org7d898d5"></a>Jerome Bruner identified three ways of thinking, or &ldquo;mentalities&rdquo;:<br>
<ol class="org-ol">
<li><a id="org47a4a1e"></a>enactive<br></li>
<li><a id="org17f7634"></a>iconic<br></li>
<li><a id="orga5db5f4"></a>symbolic<br></li>
</ol>
</li>
</ol>
</li>
<li><a id="org226b7d5"></a>&ldquo;blank canvas&rdquo; syndrome<br></li>
</ol>
</li>
</ol>
</li>
<li><a id="org5501abb"></a>Pygmalion<br>
<ol class="org-ol">
<li><a id="org9e6701e"></a>Pygmalion is a computer program that was designed to stimulate creative thinking in people<br></li>
<li><a id="org5baf5ef"></a>based on the observation that for some people blackbords provide significant aid to communication<br></li>
<li><a id="org42506a2"></a>Pygmalion is a two-dementional, visual programming environment implemented on an interactive computer with graphics display<br></li>
<li><a id="orgd51eb14"></a>It is both a programming language and a medium for experimenting with ideas<br></li>
</ol>
</li>
<li><a id="orgc3e6356"></a>retrospective<br>
<ol class="org-ol">
<li><a id="orga0963c5"></a>programming in the language of the user interface<br></li>
<li><a id="org6a818f6"></a>it is a toy system, easily run out of memories. need to build practical one<br></li>
</ol>
</li>
<li><a id="org616fed2"></a>summary<br>
<ol class="org-ol">
<li><a id="orgf34acee"></a>it allowed ideas to be worked out via sketches on the screen and then was able to reexecute the sketches on new data<br></li>
<li><a id="org71361b5"></a>it introduced icons as the basic entity for representing and controlling progerams<br></li>
<li><a id="org9b5556a"></a>programming was done by editing sketches and then recording the editing actions<br></li>
<li><a id="org0ae76b5"></a>example data were always concrete<br></li>
<li><a id="org3cd0d58"></a>it used analogical representations for data<br></li>
<li><a id="org9d4c107"></a>it represented programs as movies<br></li>
</ol>
</li>
</ol>
</div>
<div id="outline-container-org454df69" class="outline-4">
<h4 id="org454df69"><span class="section-number-4">1.1.4</span> metamouse</h4>
<div class="outline-text-4" id="text-1-1-4">
</div>
<ol class="org-ol">
<li><a id="org636d5ed"></a>introduction<br>
<ol class="org-ol">
<li><a id="org192bec8"></a>metamouse helps the user of drawing program automate repetitive editing tasks<br></li>
<li><a id="org4731003"></a>the goal of the metamouse project was to make programming as much like editing as possible, with a minimal amount of extra interaction to clarify ambiguous situations<br></li>
<li><a id="org7dcc060"></a>metamouse helps users express their intent through &ldquo;teaching&rdquo; metaphor<br></li>
<li><a id="orgde98a5d"></a>to teach effectively, users must appreciate Basil(tha name of the agent) &rsquo;s limited powers of perception and inference<br></li>
</ol>
</li>
<li><a id="org5abd83e"></a>Constraints, Interaction, and Learning<br>
<ol class="org-ol">
<li><a id="org150b501"></a>inducting transformation directly from examples of input and output is a completely intractable problem<br></li>
<li><a id="orge9bfa4a"></a>to help users understand this approach we adopted a teaching metaphor that combines demonstration, quiestion, prediction, correction and direct instruction.<br></li>
<li><a id="orgb547ac3"></a>our hypothesis was that by teaching Basil, the user would gain insights needed to use appropriate constructions. the metaphor encourages the user to take an intentional stance toward the system, rather than try to understnad its inference mechanism<br></li>
<li><a id="org4fca6b0"></a>rules of interaction between human teachers and pupils have been formulated as &ldquo;felicity conditions&rdquo;. we adopted four of them<br>
<ol class="org-ol">
<li><a id="org8afa5b0"></a>correctness<br></li>
<li><a id="org292de63"></a>show work<br></li>
<li><a id="org8f9c7cf"></a>no invisible objects<br></li>
<li><a id="org3cc4a80"></a>focus activity<br></li>
</ol>
</li>
<li><a id="org83273f1"></a>to help users obey &ldquo;correctness&rdquo; and &ldquo;focus activity&rdquo;, Basil eagerly predicts actions as soon as it detects repetition, which gives the user an early opportunity to validate what it has leared, and also minimizes the chance of the user confusing Basil by accidentally varying the way actions are done<br></li>
<li><a id="org1b49ce2"></a>the metamouse system contains elements of both similarity- and explanation-based learning.<br>
<ol class="org-ol">
<li><a id="org2973572"></a>positive examples are user demonstrations<br></li>
<li><a id="orgb982060"></a>negative examples are predictions that the user rejects<br></li>
</ol>
</li>
<li><a id="org1609ab7"></a>explanation-based learning is used in two ways<br>
<ol class="org-ol">
<li><a id="orge6ad617"></a>the user is encouraged to &ldquo;explain&rdquo; a task by employing constructive techniques to reveal implicit relationships. this differs from conventional explanation-based learning in that the user is responsible for the explanation<br></li>
</ol>
</li>
</ol>
</li>
</ol>
</div>
</div>
<div id="outline-container-org927746d" class="outline-3">
<h3 id="org927746d"><span class="section-number-3">1.2</span> memo</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-orgc6499b5" class="outline-4">
<p id="orgc6499b5"><span class="section-number-4">1.2.1</span> 体の司令は抽象的（少なくとも意識では）。たくさんの指示の階層があるにも関わらず、うまくブラックボックス化されている。コンピュータでは、その抽象化にはいたっていない。（コンピュータ内部の）機能の抽象化についてはほぼ完成され大きく変化はないが、End Userの操作における抽象化は、ほぼないといえる？
</p>
</div>
<div id="outline-container-org5e5a040" class="outline-4">
<p id="org5e5a040"><span class="section-number-4">1.2.2</span> 指示を抽象化することについて。コンピュータの操作を抽象化するということは、一つ思考のレイヤーを”上げる”ことになるので、ユーザビリティが逆に落ちてしまう？ また、ブラックボックス（コンピュータ、プログラム）の中身を知らないと抽象化できないので、コンピュータに明るくない人には抽象化は難しい？。</p>
</div>
<div id="outline-container-org5e5a040" class="outline-4">
<p id="org5e5a040"><span class="section-number-4">1.2.3</span>ユーザの操作の意図を推測することを、PBDシステムにおける主目的と捉えるならば、AI技術が進化した現在においてはPBDシステムを作ることが容易になってきているのではないか。</p>
</div>
</div>
</div>
</div>
</body>
</html>
